# Refactorial: Refactoring As The Quantum Of Creativity

## 0. Intro
![introduction][]

Refactoring is a _natural_ process for dealing with the increase in complexity of a codebase over time.
We all know how to do it, because we all know how to learn.
We enable others to refactor by creating tools and frameworks.

Evolutionary processes models the growth of the abstraction of a system, over time, in response to environmental changes.
Symbols are the base tool.
Tools enable accelerating returns (exponential growth)
All successful, complex systems are hierarchical

Learning is the process of applying consciousness to a problem.
When a skill is acquired it no longer requires conscious attention.
We can use tools to accelerate learning.

Relative intelligence is measured in the difference between the number of available levels of abstraction.
Conscious and free will evolves as a system gains a critical mass of abstraction levels.
We are the complex product of:
- signals (senses and emotions) from the environment 
- the ability to form an internal model of ourselves (reflective self-analysis = self-consciousness)
- the ability to always add another level of abstraction (12 Networking Laws, abstraction astronauts)

Quantum mechanics models the creative process.
Intention / Free will is intrinsic to our perception of the environment.
Art / Creation is the result of the potential waveform collapsing. 

## 1. Refactoring
- Refactoring is a _natural_ process
- Abstraction grows / self-realises itself Just In Time
- We need to recognise the patterns and give the abstraction a name (Naming Things Is Hard)
- Tools are named, persistent abstractions that give us super powers
- Work across as many layers of abstraction as you can
- Start small and work in onion layers

### 1.1 Hello Refactoring
```
python -c "print('Hello World')"
```
---
```
echo "def hello(something):
    print('Hello %s' % something)

hello()" > hello.py
python hello.py
```
---
```
def hello(something):
    return 'Hello %s' % something

print(hello('World'))
print(hello('PyConZA 2014'))
```
---
```
def greet_something(greeting, thing):
    return '%s %s!' % (greeting, thing)

print(greet_something('Hola', 'Senorita'))
print(greet_something('Over', 'Factored?'))
```
### 1.2 Leverage all your context
### 1.3 Leverage all the tools
### 1.4 Iterate
### 1.5 Summary
---
## 2. Evolution
### 2.1 Abstraction
### 2.2 Tool Makers Level Up Ecosystems
### 2.3 A Brief History Of Evolution
- Organisms evolve into brains
- Consciousness evolves tools
- Societies evolve communication
- Each layer stands on the shoulders of the previous paradigm shift

### 2.4 Hierarchical Indexes
### 2.5 Summary

---

## 3. Learning
### 3.1 Attention
### 3.2 Process To Pattern
### 3.3 Accelerated Skill Acquisition
### 3.4 How To Learn How To Learn
### 3.5 Summary

---

## 4. Intelligence
### 4.1 Organised Complexity 
### 4.2
### 4.3
### 4.4
### 4.5 Summary

---

## 5. Creativity
### 5.1 
### 5.2 
### 5.3 
### 5.4 
### 5.5 Summary

## 6. Outro
![epilogue][]

We exist in a series of hierarchies of complexity: [matter][], [organisms][], [societies][] and [technology][]

We are patterns, because that is what matter is (what everything is made of)
Being a product of the fabric that we find ourselves in, we have consequently evolved the ability to recognise patterns.

We can turn processes (computation?) into patterns by refactoring complexity into the background.

Therefore, we are all creators of our own reality.
And soon, computers will be too.

[introduction]:resources/introduction.jpg
[refactoring]:resources/refactoring.jpg
[evolution]:resources/evolution.jpg
[learning]:resources/learning.jpg
[intelligence]:resources/intelligence.jpg
[creativity]:resources/creativity.jpg
[epilogue]:resources/epilogue.jpg
[matter]:https://www.google.co.za/search?q=matter
[organisms]:https://www.google.co.za/search?q=biological+evolution
[societies]:https://www.google.co.za/search?q=evolution+of+human+intelligence
[technology]:https://www.google.co.za/search?q=the+law+of+accelerating+returns
